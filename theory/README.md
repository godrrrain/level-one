## 1. Какой самый эффективный способ конкатенации строк?

Если необходимо соединить много строк, то самый эффективный способ - использовать strings.Builder.WriteString(). 
Метод с оператором + тоже может быть эффективным благодаря оптимизации компилятора, так как в этом случае, конкатенация может выполняться во время компиляции, а не во время выполнения.


## 2. Что такое интерфейсы, как они применяются в Go?

Интерфейс представляет собой некое соглашение (контракт), что тот или иной объект будет реализовывать указанное в интерфейсе поведение. По сути, интерфейс - это структура, в которой описаны методы, которые должны быть реализованы для других структур, которые будут удовлетворять этому интерфейсу.


## 3. Чем отличаются RWMutex от Mutex?

RWMutex нужен, когда у нас есть объект, который нельзя параллельно писать, но можно параллельно читать. Например, стандартный тип map. Перед записью в защищаемый мьютексом объект делается .Lock(), а вызовы .Lock() и .RLock() в других горутинах будут ждать, пока мы не отпустим мьютекс через .Unlock(). Перед чтением защищаемого объекта делается .RLock() и только вызовы .Lock() в других горутинах блокируются, вызовы .RLock() спокойно проходят. Когда отпускаем мьютекс через .RUnlock(), ждущие вызовы .Lock() по-очереди могут забирать мьютекс на себя. Таких образом обеспечивается параллельное чтение объекта несколькими горутинами, что улучшает производительность.


## 4. Чем отличаются буферизированные и не буферизированные каналы?

Небуферизованный канал блокируется при попытке записать данные в канал, куда уже были записаны данные, но не были получены (передается контроль свободной горутине).
Буферизованные каналы позволяют хранить в себе определенное количество данных, не блокируя поток при записи, пока канал не заполнится.


## 5. Какой размер у структуры struct{}{}?

Если структура в Go не содержит полей, ее размер в памяти равен нулю.


## 6. Есть ли в Go перегрузка методов или операторов?

Нет.


## 7. В какой последовательности будут выведены элементы map[int]int?

В случайном порядке.


## 8. В чем разница make и new?

Функция new(T) возвращает указатель на только что выделенное нулевое значение типа T.
Функция make() — это специальная встроенная функция, которая используется для инициализации слайсов, мап и каналов. В отличие от new(), make() не возвращает указатель.


## 9. Сколько существует способов задать переменную типа slice или map?

```shell
// явно
s := []int{1, 2, 3, 4}
m := map[string]int{"one": 1, "two": 2}

// через make
s := make([]int, 10)
m := make(map[string]int)
```


## 10. Что выведет данная программа и почему?
```shell
func update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	update(p)
	fmt.Println(*p)
}
```

Программа выведет:
1
1

Так происходит, потому что при вызове функции update переменная p переопределяется внутри функции.


## 11. Что выведет данная программа и почему?
```shell
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}
```

Числа от 0 до 4 в случайном порядке, а затем deadlock.
Так происходит, потому что в качестве параметра функции, вызываемой в горутине, передается объект sync.WaitGroup, а не указатель на него.
В результате этого метод Done не уменьшает счетчик WaitGroup в главной горутине и при вызове метода Wait() происходит deadlock.


## 12. Что выведет данная программа и почему?
```shell
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

Выведет 0. Конструкция if создает новую область видимости, в которой была объявлена и проинициализирована новая переменная n.


## 13. Что выведет данная программа и почему?
```shell
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

[100 2 3 4 5]

Изменит первый элемент оригинального слайса, так как при передаче слайса указатель на массив остается тем же.
А функция append добавляет элементы в слайс и возвращает новый, присваиваяя локальной переменной v новое значение.


## 14. Что выведет данная программа и почему?
```shell
func main() {
    slice := []string{"a", "a"}
    func(slice []string) {
        slice = append(slice, "a")
        slice[0] = "b"
        slice[1] = "b"
        fmt.Print(slice)
    }(slice)
    fmt.Print(slice)
}
```

[b b a][a a]

Функция append возвращает новый slice и присваивает его локальной переменной внутри области видимости функции, не затрагивая при этом slice, который был объявлен в main.